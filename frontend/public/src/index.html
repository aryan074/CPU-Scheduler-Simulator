<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CPU Scheduling Simulator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      color: #e0e0e0;
      background-color: #121212;
      margin: 0;
      padding: 0;
      overflow-y: auto;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

.animated-bg {
  position: fixed;
  top: 0;
  left: 0;
  width: 300%;
  height: 300%;
  background: url('https://www.transparenttextures.com/patterns/stardust.png') repeat;
  background-size: 600px 600px;
  z-index: -1;
  animation: moveBg 40s linear infinite;
  opacity: 0.4; /* increased visibility */
  filter: brightness(1.2) contrast(1.2);
}

@keyframes moveBg {
  0% {
    transform: translate(0, 0);
  }
  100% {
    transform: translate(-100px, -100px);
  }
}

    @keyframes backgroundMotion {
      0% { transform: scale(1) translateY(0); }
      100% { transform: scale(1.05) translateY(-5px); }
    }

    h1, label, button {
      color: #ffffff;
      text-align: center;
    }

    button {
      background-color: #6200ea;
      border: none;
      color: white;
      padding: 10px 20px;
      cursor: pointer;
      border-radius: 5px;
      margin-top: 20px;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #3700b3;
    }

    table {
      width: 100%;
      margin-top: 20px;
      border-collapse: collapse;
      color: #ddd;
    }

    th, td {
      padding: 12px;
      text-align: left;
      border: 1px solid #444;
    }

    th {
      background-color: #333;
    }

    td {
      background-color: #1d1d1d;
    }

    .gantt-chart-container {
      display: flex;
      justify-content: center;
      margin-top: 30px;
    }

    .gantt-chart-container canvas {
      border-radius: 8px;
      background-color: #1e1e1e;
    }

    .content {
      flex-grow: 1;
      overflow-y: auto;
      padding: 20px;
      max-height: calc(100vh - 100px);
    }

    select, input, textarea {
      background-color: #333;
      color: #fff;
      border-radius: 5px;
      padding: 10px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="animated-bg"></div>
  <div class="content">
    <h1>CPU Scheduling Algorithm Simulator</h1>

    <div>
      <label for="algorithm">Choose an Algorithm:</label>
      <select id="algorithm">
        <option value="FCFS">First Come First Serve (FCFS)</option>
        <option value="SJF">Shortest Job First (SJF)</option>
        <option value="SJF-Preemptive">Shortest Job First (Preemptive)</option>
        <option value="RR">Round Robin (RR)</option>
      </select>
    </div>

    <div id="quantumInput" style="display: none;">
      <label for="quantum">Time Quantum:</label>
      <input type="number" id="quantum" min="1" value="2" />
    </div>

    <div>
      <label for="processes">Enter Process Details (ID ArrivalTime BurstTime):</label>
      <textarea id="processes" placeholder="e.g., P1 0 5, P2 1 3, P3 2 8"></textarea>
    </div>

    <button onclick="startSimulation()">Start Simulation</button>

    <div class="gantt-chart-container">
      <canvas id="ganttChart"></canvas>
    </div>

    <h2>Scheduling Results</h2>
    <table id="resultTable">
      <thead>
        <tr>
          <th>Process</th>
          <th>Arrival Time</th>
          <th>Burst Time</th>
          <th>Completion Time</th>
          <th>Turnaround Time</th>
          <th>Waiting Time</th>
        </tr>
      </thead>
      <tbody></tbody>
      <tfoot>
        <tr>
          <td colspan="4">Average</td>
          <td id="avgTAT">-</td>
          <td id="avgWT">-</td>
        </tr>
      </tfoot>
    </table>
  </div>

  <script>
    document.getElementById('algorithm').addEventListener('change', function () {
      document.getElementById('quantumInput').style.display = this.value === 'RR' ? 'block' : 'none';
    });

    function startSimulation() {
      const input = document.getElementById('processes').value.trim();
      const algorithm = document.getElementById('algorithm').value;
      const quantum = parseInt(document.getElementById('quantum')?.value) || 2;

      if (!input) return alert("Please enter process details!");

      const processes = input.split(',').map(str => {
        const [id, arrival, burst] = str.trim().split(' ');
        return {
          id,
          arrival: parseInt(arrival),
          burst: parseInt(burst),
          remaining: parseInt(burst)
        };
      });

      let result = [];

      switch (algorithm) {
        case 'FCFS':
          result = simulateFCFS(processes);
          break;
        case 'SJF':
          result = simulateSJF(processes);
          break;
        case 'SJF-Preemptive':
          result = simulateSJFPreemptive(processes);
          break;
        case 'RR':
          result = simulateRR(processes, quantum);
          break;
      }

      renderResults(result);
      const ganttData = result.map(p => p.gantt).flat();
      renderGanttChart(ganttData);
    }

    function simulateFCFS(processes) {
      processes.sort((a, b) => a.arrival - b.arrival);
      let currentTime = 0;
      return processes.map((p, i) => {
        const start = Math.max(currentTime, p.arrival);
        const end = start + p.burst;
        currentTime = end;
        return {
          ...p,
          completion: end,
          tat: end - p.arrival,
          wt: start - p.arrival,
          gantt: [{
            label: p.id,
            x: start,
            data: [p.burst],
            backgroundColor: generateColors(i)
          }]
        };
      });
    }

    function simulateSJF(processes) {
      const ready = [], result = [];
      let time = 0, done = 0;
      const n = processes.length;
      processes.forEach(p => p.visited = false);

      while (done < n) {
        processes.forEach(p => {
          if (!p.visited && p.arrival <= time) {
            ready.push(p);
            p.visited = true;
          }
        });

        if (ready.length === 0) {
          time++;
          continue;
        }

        ready.sort((a, b) => a.burst - b.burst);
        const p = ready.shift();
        const start = Math.max(time, p.arrival);
        const end = start + p.burst;
        time = end;
        done++;

        result.push({
          ...p,
          completion: end,
          tat: end - p.arrival,
          wt: start - p.arrival,
          gantt: [{
            label: p.id,
            x: start,
            data: [p.burst],
            backgroundColor: generateColors(done)
          }]
        });
      }

      return result;
    }

    function simulateSJFPreemptive(processes) {
      let time = 0, completed = 0;
      const n = processes.length;
      const gantt = [];
      const resultMap = {};
      let lastId = null;

      processes.forEach(p => {
        p.remaining = p.burst;
        p.visited = false;
      });

      while (completed < n) {
        let ready = processes.filter(p => p.arrival <= time && p.remaining > 0);
        if (ready.length === 0) {
          time++;
          continue;
        }

        ready.sort((a, b) => a.remaining - b.remaining || a.arrival - b.arrival);
        const p = ready[0];

        if (lastId !== p.id) {
          gantt.push({
            label: p.id,
            x: time,
            data: [1],
            backgroundColor: generateColors(p.id.charCodeAt(0))
          });
        } else {
          gantt[gantt.length - 1].data[0]++;
        }

        p.remaining--;
        if (p.remaining === 0) {
          completed++;
          p.completion = time + 1;
          resultMap[p.id] = {
            ...p,
            tat: p.completion - p.arrival,
            wt: p.completion - p.arrival - p.burst
          };
        }

        lastId = p.id;
        time++;
      }

      Object.values(resultMap).forEach(p => {
        p.gantt = gantt.filter(g => g.label === p.id);
      });

      return Object.values(resultMap);
    }

    function simulateRR(processes, quantum) {
      const queue = [];
      const result = [];
      const gantt = [];
      const n = processes.length;
      let time = 0, completed = 0;

      processes.sort((a, b) => a.arrival - b.arrival);
      const arrivalMap = [...processes];

      while (completed < n) {
        arrivalMap.forEach(p => {
          if (!p.queued && p.arrival <= time) {
            queue.push(p);
            p.queued = true;
          }
        });

        if (queue.length === 0) {
          time++;
          continue;
        }

        const p = queue.shift();
        const execTime = Math.min(p.remaining, quantum);
        const start = time;
        const end = start + execTime;
        time = end;
        p.remaining -= execTime;

        gantt.push({
          label: p.id,
          x: start,
          data: [execTime],
          backgroundColor: generateColors(p.id.charCodeAt(0))
        });

        arrivalMap.forEach(proc => {
          if (!proc.queued && proc.arrival <= time) {
            queue.push(proc);
            proc.queued = true;
          }
        });

        if (p.remaining > 0) {
          queue.push(p);
        } else {
          completed++;
          p.completion = time;
          result.push({
            ...p,
            tat: p.completion - p.arrival,
            wt: p.completion - p.arrival - p.burst,
            gantt: []
          });
        }
      }

      result.forEach(p => {
        p.gantt = gantt.filter(g => g.label === p.id);
      });

      return result;
    }

    function renderResults(processes) {
      const tbody = document.querySelector('#resultTable tbody');
      tbody.innerHTML = '';
      let totalTAT = 0, totalWT = 0;

      processes.forEach(p => {
        totalTAT += p.tat;
        totalWT += p.wt;
        tbody.innerHTML += `
          <tr>
            <td>${p.id}</td>
            <td>${p.arrival}</td>
            <td>${p.burst}</td>
            <td>${p.completion}</td>
            <td>${p.tat}</td>
            <td>${p.wt}</td>
          </tr>`;
      });

      document.getElementById('avgTAT').textContent = (totalTAT / processes.length).toFixed(2);
      document.getElementById('avgWT').textContent = (totalWT / processes.length).toFixed(2);
    }

    let chartInstance;

function renderGanttChart(ganttData) {
  const ctx = document.getElementById('ganttChart').getContext('2d');
  if (chartInstance) chartInstance.destroy();

  const labels = [...new Set(ganttData.map(g => g.label))];

  chartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: ganttData.map(g => ({
        label: g.label,
        data: [{
          y: g.label,
          x: [g.x, g.x + g.data[0]]
        }],
        backgroundColor: g.backgroundColor,
        borderSkipped: false,
        barPercentage: 1.0,
        categoryPercentage: 1.0
      }))
    },
    options: {
      indexAxis: 'y',
      parsing: {
        xAxisKey: 'x',
        yAxisKey: 'y'
      },
      scales: {
        x: { type: 'linear', beginAtZero: true, title: { display: true, text: 'Time' } },
        y: { type: 'category', labels: labels, title: { display: true, text: 'Processes' } }
      },
      plugins: { legend: { display: false } },
      responsive: true
    }
  });
}

    function generateColors(seed) {
      const colors = [
        '#e63946', '#2a9d8f', '#f4a261', '#264653', '#a8dadc',
        '#e9c46a', '#6d597a', '#ffb4a2', '#b5ead7', '#caffbf'
      ];
      return colors[seed % colors.length];
    }
  </script>
</body>
</html>
